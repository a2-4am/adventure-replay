;license:MIT
;(c) 2023 by 4am
;

         !src  "../common/src/constants.a"
         !src  "../common/src/macros.a"

; exits with Z=1
!macro INSTALL_BETTER_INPUT {
         +SHORT_COPY better_input_start, better_input_end, INPUT
}

;------------------------------------------------------------------------------
; BetterInput routine
; hook in interactive game mode to provide a better user experience when
; typing
;------------------------------------------------------------------------------
better_input_start
!pseudopc INPUT {
BeginBetterInput
         ldy   CH
         cpy   min_ch
         bcs   @checkInputMode
         sty   min_ch
@checkInputMode
         lda   input_mode
         bmi   +
         iny
         jsr   ROM_CLREOL_FROM_Y
         ldy   CH
         lda   #$20
         sta   (BASL), y
;+        rts

PendingBetterInput
input_mode=*+1
         lda   #$00                  ; self-modified
         bmi   @pendingNonInteractive
         lda   KBD
+        rts

@pendingNonInteractive
         lsr
         bcc   @pendingInputMode2
         cpy   min_ch
         beq   @beginRetypingLastCommand
         ; return left arrow until we're back at the beginning of the input line
         lda   #$88
         rts

@beginRetypingLastCommand
         dec   input_mode
         ; /!\ execution falls through here

@pendingInputMode2
         ; return the next character from the saved input buffer
input_offset=*+1
         ldy   #$00                  ; self-modified
         lda   last_input, y
         beq   @goToInputMode0
         ldy   CH
         cmp   #0
         rts

@goToInputMode0
         ;A=0
         sta   input_mode
         sta   input_offset
         rts

NonBlockingBetterInput
         jsr   BeginBetterInput
         jsr   PendingBetterInput
         bpl   @exit
         jsr   AcceptableBetterInput
         bcc   @accept
         lda   #0
@accept  adc   #0                    ; sets N flag for caller
@exit    rts

BlockingBetterInput
         jsr   BeginBetterInput
         jsr   PendingBetterInput
         bpl   BlockingBetterInput
         bit   CLEARKBD
         jsr   AcceptableBetterInput
         bcs   BlockingBetterInput
         ; /!\ execution falls through here to CommitBetterInput

CommitBetterInput
; in:    A=key to commit
; out:   A/X preserved
;        Y=CH
;        N=0
;        Z=0
;        C clobbered
         ldy   CH
         sta   (BASL), y
         lda   input_mode
         cmp   #$FE
         bne   +
         inc   input_offset
+        bit   CLEARKBD
         lda   (BASL), y
         rts

AcceptableBetterInput
; in:    A=key pressed
;        Y=CH
; out:   C=0 if key should be accepted
;        C=1 if key should be rejected
;        A=(possibly altered) key
;        Y preserved
;        X preserved

         ; convert backspace to left arrow
         cmp   #$FF
         bne   @checkUpArrow
         lda   #$88                  ; left arrow
@checkUpArrow
         ; up arrow = retype last command
         cmp   #$8B                  ; up arrow
         bne   @checkOtherArrows
         lda   last_input
         beq   RejectInput           ; ignore if no previous command
         dec   input_mode
         bne   RejectInput           ; always branches
@checkOtherArrows
         ; ignore other arrows
         cmp   #$8A                  ; down arrow
         beq   RejectInput
         cmp   #$95                  ; right arrow
         beq   RejectInput

         ; convert lowercase to uppercase
         jsr   ToUpper

         ; if no input yet, we're done (don't check for <return>)
         cpy   min_ch
         beq   @accept

         cmp   #$8D
         bne   @checkMax
         ; on <return> after non-empty input, save input in internal buffer
min_ch=*+1
         ldy   #$28                  ; self-modified
         pha
         txa
         pha
         ldx   #$00
-        lda   (BASL), y
         jsr   ToUpper               ; some games (e.g. QuestProbe) only accept
                                     ; uppercase input while simultaneously
                                     ; auto-lowercasing it for display, so we
                                     ; need to re-convert to uppercase here
         sta   last_input, x
         inx
         iny
         cpy   CH
         bcc   -
         ;Y=CH
         lda   #$28
         sta   min_ch
         lda   #$00
         sta   last_input, x
         pla
         tax
         pla
         clc
         rts

@checkMax
         ; check if input line is at max length
         cpy   #$27
         bcc   @accept

         ; maxed out! only accept left arrow (or <return>, already handled)
         cmp   #$88
         bne   RejectInput

@accept  clc
         rts

ToUpper
         cmp   #$E1
         bcc   +
         cmp   #$FB
         bcs   +
         and   #$DF
RejectInput
         sec
+        rts

last_input
         !fill $26
}
better_input_end

!if (better_input_end-better_input_start) > $100 {
         !serious "BetterInput routine is too long, ", better_input_end-better_input_start, " bytes"
}
